#!/usr/bin/env python3
"""
Figure 4: Original vs. compensated frames for a forward scan.

This script consumes the time-binned frame NPZ generated by
``compensate_multiwindow_train_saved_params.py`` and emits a clean,
publication-ready comparison between the uncompensated and compensated
accumulations for one or more 50 ms bins.

Usage
-----
    python figure04_reconstruction.py \
        --segment /path/to/Scan_1_Forward_events.npz \
        --bins 10 \
        --output-dir publication_code/figures/figure04

Options
-------
--segment        Path to a forward/backward segment NPZ (required).
--bins           One or more 0-based bin indices to average (default: middle bin).
--aggregate      Aggregation method when multiple bins are provided:
                 "mean" (default) or "sum".
--colormap       Matplotlib colormap (default: "magma").
--percentiles    Lower/upper percentiles for colour scaling (default: 1 99).
--output-dir     Output directory (default: figures/figure04 alongside this script).
--save-png       Emit a PNG alongside the PDF.

Outputs
-------
  figure04_reconstruction.pdf  – aggregated comparison (default behaviour).
  figure04_bin_XX.pdf          – per-bin comparisons when --all-bins is used.
  PNG counterparts are emitted alongside PDFs if --save-png is set.
"""

from __future__ import annotations

import argparse
import glob
import os
from pathlib import Path
from typing import Iterable, List

import numpy as np
import matplotlib.pyplot as plt


def setup_style() -> None:
    plt.rcParams.update(
        {
            "font.size": 9,
            "axes.titlesize": 9,
            "axes.linewidth": 0.8,
            "xtick.direction": "out",
            "ytick.direction": "out",
            "xtick.major.size": 3,
            "ytick.major.size": 3,
        }
    )


def find_latest(pattern: str) -> Path:
    matches = glob.glob(pattern)
    if not matches:
        raise FileNotFoundError(f"No files matched pattern: {pattern}")
    latest = max(matches, key=os.path.getmtime)
    return Path(latest)


def locate_timebin_npz(segment_npz: Path) -> Path:
    tb_dir = segment_npz.parent / "time_binned_frames"
    if not tb_dir.is_dir():
        raise FileNotFoundError(f"Time-binned directory missing: {tb_dir}")
    base = segment_npz.stem
    pattern = str(tb_dir / f"{base}_chunked_processing_all_time_bins_data_*.npz")
    return find_latest(pattern)


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Generate Figure 4 original vs compensated comparison.")
    parser.add_argument(
        "--segment",
        type=Path,
        required=True,
        help="Path to Scan_*_Forward_events.npz (or backward).",
    )
    parser.add_argument(
        "--bins",
        type=int,
        nargs="+",
        help="0-based bin indices to include. Default: middle bin.",
    )
    parser.add_argument(
        "--aggregate",
        choices=("mean", "sum"),
        default="mean",
        help="Aggregation method when multiple bins are provided.",
    )
    parser.add_argument(
        "--colormap",
        default="magma",
        help="Matplotlib colormap name (default: magma).",
    )
    parser.add_argument(
        "--percentiles",
        type=float,
        nargs=2,
        default=(1.0, 99.0),
        metavar=("LOW", "HIGH"),
        help="Lower/upper percentiles for colour scaling (default: 1 99).",
    )
    parser.add_argument(
        "--all-bins",
        action="store_true",
        help="Render every available bin as an individual comparison figure.",
    )
    parser.add_argument(
        "--output-dir",
        type=Path,
        default=Path(__file__).resolve().parent / "figures" / "figure04",
        help="Directory to store the generated figure(s).",
    )
    parser.add_argument(
        "--save-png",
        action="store_true",
        help="Emit a PNG alongside the PDF.",
    )
    return parser.parse_args()


def select_bins(num_bins: int, explicit: Iterable[int] | None) -> List[int]:
    if explicit:
        bins = sorted(set(explicit))
    else:
        bins = [num_bins // 2]
    for idx in bins:
        if idx < 0 or idx >= num_bins:
            raise ValueError(f"Requested bin index {idx} outside valid range [0, {num_bins - 1}]")
    return bins


def aggregate_frames(data: dict[str, np.ndarray], bins: List[int], aggregate: str) -> tuple[np.ndarray, np.ndarray]:
    originals = [data[f"original_bin_{idx}"] for idx in bins]
    compensated = [data[f"compensated_bin_{idx}"] for idx in bins]
    stacked_orig = np.stack(originals, axis=0)
    stacked_comp = np.stack(compensated, axis=0)
    if aggregate == "sum":
        return stacked_orig.sum(axis=0), stacked_comp.sum(axis=0)
    return stacked_orig.mean(axis=0), stacked_comp.mean(axis=0)


def normalise_images(orig: np.ndarray, comp: np.ndarray, low: float, high: float) -> tuple[float, float]:
    """Return vmin/vmax shared between the two arrays using percentile scaling."""
    combined = np.concatenate([orig.ravel(), comp.ravel()])
    vmin = np.percentile(combined, low)
    vmax = np.percentile(combined, high)
    if np.isclose(vmin, vmax):
        vmax = vmin + 1e-3
    return float(vmin), float(vmax)


def compute_global_limits(data: dict[str, np.ndarray], bins: List[int], low: float, high: float) -> tuple[float, float]:
    """Compute colour limits across all requested bins and both modalities."""
    arrays = []
    for idx in bins:
        arrays.append(data[f"original_bin_{idx}"])
        arrays.append(data[f"compensated_bin_{idx}"])
    combined = np.concatenate([arr.ravel() for arr in arrays]).astype(np.float32)
    vmin = np.percentile(combined, low)
    vmax = np.percentile(combined, high)
    if np.isclose(vmin, vmax):
        vmax = vmin + 1e-3
    return float(vmin), float(vmax)


def render_figure(
    original: np.ndarray,
    compensated: np.ndarray,
    bins: List[int],
    bin_width_ms: float,
    colormap: str,
    vmin: float,
    vmax: float,
    output_dir: Path,
    save_png: bool,
    output_basename: str,
) -> None:
    setup_style()
    fig, axes = plt.subplots(1, 2, figsize=(6.0, 3.2), constrained_layout=True)

    if len(bins) == 1:
        metadata = f"Bin {bins[0]} ({bin_width_ms:.0f} ms)"
    else:
        metadata = f"Bins {', '.join(str(b) for b in bins)} × {bin_width_ms:.0f} ms"

    im0 = axes[0].imshow(original, cmap=colormap, vmin=vmin, vmax=vmax, origin="lower")
    axes[0].set_title("Original")
    axes[0].axis("off")
    axes[0].text(
        0.02,
        0.02,
        metadata,
        transform=axes[0].transAxes,
        fontsize=8,
        color="black",
    )

    im1 = axes[1].imshow(compensated, cmap=colormap, vmin=vmin, vmax=vmax, origin="lower")
    axes[1].set_title("Compensated")
    axes[1].axis("off")

    cbar = fig.colorbar(im1, ax=axes.ravel().tolist(), shrink=0.85, pad=0.02)
    cbar.ax.set_ylabel("Accumulated events (a.u.)", rotation=90)

    fig.text(0.012, 0.97, "(a)", fontweight="bold", ha="left", va="top")
    output_dir.mkdir(parents=True, exist_ok=True)
    pdf_path = output_dir / f"{output_basename}.pdf"
    fig.savefig(pdf_path, dpi=400, bbox_inches="tight")
    if save_png:
        fig.savefig(output_dir / f"{output_basename}.png", dpi=300, bbox_inches="tight")
    plt.close(fig)
    print(f"Saved figure to {pdf_path}")


def main() -> None:
    args = parse_args()

    segment_npz = args.segment.resolve()
    if not segment_npz.exists():
        raise FileNotFoundError(segment_npz)

    timebin_npz = locate_timebin_npz(segment_npz)
    print(f"Using time-binned frames: {timebin_npz}")

    output_dir = args.output_dir.resolve()

    with np.load(timebin_npz, allow_pickle=True) as data:
        num_bins = int(data["num_bins"])
        bin_width_ms = float(data["bin_width_ms"])

        if args.all_bins:
            if args.bins:
                bins = select_bins(num_bins, args.bins)
            else:
                bins = list(range(num_bins))
            vmin, vmax = compute_global_limits(data, bins, *args.percentiles)
            print(f"Global value range [{vmin:.3f}, {vmax:.3f}] across bins {bins}")
            for idx in bins:
                original, compensated = aggregate_frames(data, [idx], args.aggregate)
                render_figure(
                    original,
                    compensated,
                    [idx],
                    bin_width_ms,
                    args.colormap,
                    vmin,
                    vmax,
                    output_dir,
                    args.save_png,
                    output_basename=f"figure04_bin_{idx:02d}",
                )
        else:
            bins = select_bins(num_bins, args.bins)
            original, compensated = aggregate_frames(data, bins, args.aggregate)
            vmin, vmax = normalise_images(original, compensated, *args.percentiles)
            print(f"Value range [{vmin:.3f}, {vmax:.3f}] based on percentiles {args.percentiles}")
            render_figure(
                original,
                compensated,
                bins,
                bin_width_ms,
                args.colormap,
                vmin,
                vmax,
                output_dir,
                args.save_png,
                output_basename="figure04_reconstruction",
            )


if __name__ == "__main__":
    main()
