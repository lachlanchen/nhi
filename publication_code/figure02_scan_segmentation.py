#!/usr/bin/env python3
"""
Produce publication-ready figures that visualise the self-synchronised scan
segmentation pipeline. The script ingests segmented event archives generated by
``segment_robust_fixed.py`` and emits three standalone figures:

    1. figure02_main.pdf       – Activity trace and correlation diagnostics
    2. figure02_duration.pdf   – Half-scan duration distributions (supporting)
    3. figure02_eventrate.pdf  – Event-rate convergence over fused scans

Each figure is formatted for Optics Letters column widths with minimal textual
clutter. Outputs are written to ``publication_code/figures`` by default.
"""

from __future__ import annotations

import argparse
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, List, Sequence, Tuple

import matplotlib.patches as mpatches
import matplotlib.pyplot as plt
import numpy as np


REPO_ROOT = Path(__file__).resolve().parents[1]
DEFAULT_SEGMENTS = (
    REPO_ROOT
    / "scan_angle_20_led_2835b"
    / "angle_20_blank_2835_20250925_184747"
    / "angle_20_blank_2835_event_20250925_184747_segments"
)
DEFAULT_OUTPUT_DIR = Path(__file__).resolve().parent / "figures"


@dataclass
class SegmentInfo:
    """Metadata describing a forward or backward scan segment."""

    dataset: str
    scan_id: int
    direction: str
    start_us: int
    end_us: int
    event_count: int
    occupancy_us: float
    event_rate: float
    npz_path: Path


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Generate publication-quality figures for scan segmentation diagnostics."
    )
    parser.add_argument(
        "--dataset-path",
        type=Path,
        default=DEFAULT_SEGMENTS,
        help="Path to a *_segments directory produced by segment_robust_fixed.py.",
    )
    parser.add_argument(
        "--time-bin-us",
        type=int,
        default=1000,
        help="Temporal bin size in microseconds when forming the activity trace.",
    )
    parser.add_argument(
        "--output-dir",
        type=Path,
        default=DEFAULT_OUTPUT_DIR,
        help="Directory where PDF/PNG figures will be written.",
    )
    parser.add_argument(
        "--save-png",
        action="store_true",
        help="Emit companion PNG renders for quick previews.",
    )
    return parser.parse_args()


def find_segment_dirs(base_dir: Path) -> List[Path]:
    """Locate *_segments directories under ``base_dir``."""

    if base_dir.is_dir() and base_dir.name.endswith("_segments"):
        return [base_dir]
    return [
        path
        for path in base_dir.rglob("*_segments")
        if path.is_dir() and any(path.glob("Scan_*_events.npz"))
    ]


def load_segment_infos(segment_dir: Path) -> List[SegmentInfo]:
    """Extract metadata for every segment within ``segment_dir``."""

    dataset_name = segment_dir.parent.name
    infos: List[SegmentInfo] = []
    for npz_path in sorted(segment_dir.glob("Scan_*_events.npz")):
        with np.load(npz_path) as data:
            start_us = int(data["start_time"])
            end_us = int(data["end_time"])
            scan_id = int(data["scan_id"])
            direction = str(data["direction"])
            event_count = int(data["event_count"])
            timestamps = data["t"].astype(np.int64)
        occupancy_us = float(timestamps[-1] - timestamps[0])
        duration_ms = (end_us - start_us) / 1000.0
        window_ms = duration_ms if duration_ms > 0 else max(occupancy_us / 1000.0, 1.0)
        event_rate = event_count / window_ms
        infos.append(
            SegmentInfo(
                dataset=dataset_name,
                scan_id=scan_id,
                direction=direction,
                start_us=start_us,
                end_us=end_us,
                event_count=event_count,
                occupancy_us=occupancy_us,
                event_rate=event_rate,
                npz_path=npz_path,
            )
        )
    return infos


def compute_activity_trace(
    segments: Sequence[SegmentInfo],
    time_bin_us: int,
) -> Tuple[np.ndarray, np.ndarray]:
    """Return time (seconds) and activity (events per millisecond) arrays."""

    if not segments:
        raise ValueError("No segments available to build activity trace.")

    start_us = min(seg.start_us for seg in segments)
    end_us = max(seg.end_us for seg in segments)
    num_bins = int(np.ceil((end_us - start_us) / time_bin_us))

    activity = np.zeros(num_bins, dtype=np.int64)
    for seg in segments:
        with np.load(seg.npz_path) as data:
            bin_indices = ((data["t"].astype(np.int64) - start_us) // time_bin_us).astype(np.int64)
        counts = np.bincount(bin_indices, minlength=num_bins)
        activity[: len(counts)] += counts

    centres_us = start_us + (np.arange(num_bins) + 0.5) * time_bin_us
    reference_us = segments[0].start_us
    time_s = (centres_us - reference_us) / 1_000_000.0
    activity_millions = activity.astype(np.float64) / 1_000_000.0
    return time_s, activity_millions


def compute_correlations(activity: np.ndarray, time_bin_us: int) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
    """Compute auto- and reverse-correlations of the activity sequence."""

    demeaned = activity - np.mean(activity)
    auto = np.correlate(demeaned, demeaned, mode="full")
    reverse = np.correlate(demeaned, demeaned[::-1], mode="full")
    auto /= np.max(np.abs(auto))
    reverse /= np.max(np.abs(reverse))
    lags_ms = np.arange(-len(activity) + 1, len(activity)) * (time_bin_us / 1000.0)
    return lags_ms, auto, reverse


def find_positive_peak(lags_ms: np.ndarray, corr: np.ndarray) -> float:
    """Return the lag associated with the strongest positive-side peak."""

    midpoint = len(corr) // 2
    positive = corr[midpoint + 1 :]
    peak_idx = np.argmax(positive)
    return lags_ms[midpoint + 1 + peak_idx]


def setup_figure_style() -> None:
    plt.rcParams.update(
        {
            "font.size": 9,
            "axes.labelsize": 9,
            "axes.titlesize": 9,
            "axes.linewidth": 0.8,
            "xtick.direction": "out",
            "ytick.direction": "out",
            "xtick.major.size": 3,
            "ytick.major.size": 3,
            "legend.frameon": False,
        }
    )


def render_main_figure(
    output_dir: Path,
    time_s: np.ndarray,
    activity_millions: np.ndarray,
    segments: Sequence[SegmentInfo],
    lags_ms: np.ndarray,
    auto_corr: np.ndarray,
    reverse_corr: np.ndarray,
    one_way_ms: float,
    turnaround_ms: float,
    save_png: bool,
) -> None:
    """Create the main two-panel figure (activity + correlation)."""

    fig, axes = plt.subplots(2, 1, figsize=(6.1, 5.0), sharex=False)

    palette = {"Forward": "#1f77b4", "Backward": "#d94801"}
    ax0 = axes[0]
    ax0.plot(time_s, activity_millions, color="#08306b", linewidth=1.4)
    for seg in segments:
        seg_start = (seg.start_us - segments[0].start_us) / 1_000_000.0
        seg_end = (seg.end_us - segments[0].start_us) / 1_000_000.0
        ax0.axvspan(seg_start, seg_end, color=palette[seg.direction], alpha=0.18, lw=0)

    forward_patch = mpatches.Patch(color=palette["Forward"], alpha=0.25, label="Forward scans")
    backward_patch = mpatches.Patch(color=palette["Backward"], alpha=0.25, label="Backward scans")
    ax0.legend(handles=[forward_patch, backward_patch], loc="upper right", fontsize=8)
    ax0.set_ylabel("Events per ms (×10⁶)")
    ax0.set_xlim(time_s[0], time_s[-1])
    ax0.grid(axis="y", linestyle=":", linewidth=0.6, alpha=0.5)
    ax0.spines["top"].set_visible(False)
    ax0.spines["right"].set_visible(False)
    ax0.text(
        0.01,
        0.92,
        "(a) Activity trace with segment labels",
        transform=ax0.transAxes,
        fontweight="bold",
        ha="left",
        va="top",
    )

    ax1 = axes[1]
    ax1.plot(lags_ms / 1000.0, auto_corr, color="#225ea8", linewidth=1.4, label="Auto-correlation")
    ax1.plot(
        lags_ms / 1000.0,
        reverse_corr,
        color="#cb181d",
        linewidth=1.2,
        linestyle="--",
        label="Reverse correlation",
    )
    ax1.axvline(one_way_ms / 1000.0, color="#225ea8", linestyle=":", linewidth=1.0)
    ax1.axvline(-one_way_ms / 1000.0, color="#225ea8", linestyle=":", linewidth=1.0)
    ax1.axvline(turnaround_ms / 1000.0, color="#cb181d", linestyle=":", linewidth=1.0)
    ax1.set_xlabel("Lag (s)")
    ax1.set_ylabel("Normalised magnitude")
    ax1.set_xlim(-4.0, 4.0)
    ax1.set_ylim(-0.1, 1.05)
    ax1.legend(loc="upper right", fontsize=8)
    ax1.grid(True, linestyle=":", linewidth=0.6, alpha=0.5)
    ax1.spines["top"].set_visible(False)
    ax1.spines["right"].set_visible(False)
    ax1.text(
        0.01,
        0.92,
        "(b) Correlation diagnostics",
        transform=ax1.transAxes,
        fontweight="bold",
        ha="left",
        va="top",
    )

    fig.subplots_adjust(hspace=0.38, top=0.92, bottom=0.12, left=0.12, right=0.98)
    fig.text(
        0.5,
        0.04,
        "Figure 2. Self-synchronised scan segmentation diagnostics.",
        ha="center",
        fontsize=9,
    )

    pdf_path = output_dir / "figure02_main.pdf"
    fig.savefig(pdf_path, dpi=400)
    if save_png:
        fig.savefig(output_dir / "figure02_main.png", dpi=400)
    plt.close(fig)
    print(f"Saved main figure to {pdf_path}")


def render_duration_figure(
    output_dir: Path,
    all_segments: Sequence[SegmentInfo],
    save_png: bool,
) -> None:
    """Create a supporting histogram of half-scan durations."""

    durations_s = np.array([seg.occupancy_us / 1_000_000.0 for seg in all_segments])
    directions = np.array([seg.direction for seg in all_segments])
    forward = durations_s[directions == "Forward"]
    backward = durations_s[directions == "Backward"]

    if forward.size == 0 or backward.size == 0:
        return

    bins = np.linspace(durations_s.min() * 0.98, durations_s.max() * 1.02, 16)
    fig, ax = plt.subplots(figsize=(6.1, 2.6))
    ax.hist(
        forward,
        bins=bins,
        histtype="step",
        linewidth=1.6,
        color="#1f77b4",
        label="Forward",
    )
    ax.hist(
        backward,
        bins=bins,
        histtype="step",
        linewidth=1.6,
        color="#d94801",
        label="Backward",
    )
    ax.set_xlabel("Half-scan duration (s)")
    ax.set_ylabel("Count")
    ax.grid(axis="y", linestyle=":", linewidth=0.5, alpha=0.5)
    ax.spines["top"].set_visible(False)
    ax.spines["right"].set_visible(False)
    ax.legend(loc="upper right", fontsize=8)
    ax.text(
        0.01,
        0.92,
        "Half-scan duration stability",
        transform=ax.transAxes,
        fontweight="bold",
        ha="left",
        va="top",
    )
    fig.subplots_adjust(top=0.85, bottom=0.22, left=0.12, right=0.97)
    fig.text(
        0.5,
        0.02,
        "Supplementary: duration distributions across forward/back scans.",
        ha="center",
        fontsize=9,
    )
    pdf_path = output_dir / "figure02_duration.pdf"
    fig.savefig(pdf_path, dpi=400)
    if save_png:
        fig.savefig(output_dir / "figure02_duration.png", dpi=400)
    plt.close(fig)
    print(f"Saved duration figure to {pdf_path}")


def render_eventrate_figure(
    output_dir: Path,
    segments: Sequence[SegmentInfo],
    save_png: bool,
) -> None:
    """Create a supporting plot showing cumulative event-rate convergence."""

    forward_rates = [seg.event_rate for seg in segments if seg.direction == "Forward"]
    backward_rates = [seg.event_rate for seg in segments if seg.direction == "Backward"]

    if not forward_rates or not backward_rates:
        return

    forward_cum = np.cumsum(forward_rates) / np.arange(1, len(forward_rates) + 1)
    backward_cum = np.cumsum(backward_rates) / np.arange(1, len(backward_rates) + 1)
    scans = np.arange(1, max(len(forward_cum), len(backward_cum)) + 1)

    fig, ax = plt.subplots(figsize=(6.1, 2.6))
    ax.plot(scans[: len(forward_cum)], forward_cum, marker="o", color="#1f77b4", label="Forward")
    ax.plot(scans[: len(backward_cum)], backward_cum, marker="s", color="#d94801", label="Backward")
    pooled_mean = np.mean(forward_rates + backward_rates)
    ax.axhline(pooled_mean, color="black", linestyle="--", linewidth=1.0, label="All scans mean")
    ax.set_xlabel("Number of fused scans")
    ax.set_ylabel("Events per ms")
    ax.set_xticks(scans)
    ax.grid(True, linestyle=":", linewidth=0.5, alpha=0.5)
    ax.spines["top"].set_visible(False)
    ax.spines["right"].set_visible(False)
    ax.legend(loc="upper right", fontsize=8)
    ax.text(
        0.01,
        0.92,
        "Multi-pass event-rate convergence",
        transform=ax.transAxes,
        fontweight="bold",
        ha="left",
        va="top",
    )
    fig.subplots_adjust(top=0.85, bottom=0.22, left=0.12, right=0.97)
    fig.text(
        0.5,
        0.02,
        "Supplementary: cumulative event-rate stabilises with additional scans.",
        ha="center",
        fontsize=9,
    )
    pdf_path = output_dir / "figure02_eventrate.pdf"
    fig.savefig(pdf_path, dpi=400)
    if save_png:
        fig.savefig(output_dir / "figure02_eventrate.png", dpi=400)
    plt.close(fig)
    print(f"Saved event-rate figure to {pdf_path}")


def main() -> None:
    args = parse_args()
    dataset_path = args.dataset_path.expanduser().resolve()
    output_dir = args.output_dir.expanduser().resolve()
    output_dir.mkdir(parents=True, exist_ok=True)

    segment_dirs = find_segment_dirs(dataset_path)
    if not segment_dirs:
        raise FileNotFoundError(f"No *_segments directories found beneath {dataset_path}")

    target_segments = load_segment_infos(segment_dirs[0])
    all_segments: List[SegmentInfo] = []
    for seg_dir in find_segment_dirs(segment_dirs[0].parents[1]):
        all_segments.extend(load_segment_infos(seg_dir))

    time_s, activity_millions = compute_activity_trace(target_segments, args.time_bin_us)
    lags_ms, auto_corr, reverse_corr = compute_correlations(activity_millions, args.time_bin_us)
    one_way_ms = find_positive_peak(lags_ms, auto_corr)
    turnaround_ms = find_positive_peak(lags_ms, reverse_corr)

    setup_figure_style()
    render_main_figure(
        output_dir=output_dir,
        time_s=time_s,
        activity_millions=activity_millions,
        segments=target_segments,
        lags_ms=lags_ms,
        auto_corr=auto_corr,
        reverse_corr=reverse_corr,
        one_way_ms=one_way_ms,
        turnaround_ms=turnaround_ms,
        save_png=args.save_png,
    )
    render_duration_figure(output_dir=output_dir, all_segments=all_segments, save_png=args.save_png)
    render_eventrate_figure(output_dir=output_dir, segments=target_segments, save_png=args.save_png)


if __name__ == "__main__":
    main()
